#
#	HEADER
#		name:		HIDEMARU Editor's Macro Subroutine Library
#						Auto Linkaging AWK Script
#		filename:	gen_mac.awk
#		version:	0.03
#		author:		M. Sugiura(sugiura@ceres.dti.ne.jp)
#		date:		1998/02/27
#
#	DOCUMENT
#
#		説明：
#			マクロソースファイル中のサブルーチンコールを読み取って、
#			不足分をサブルーチンライブラリから取得する
#			(サブルーチン中のサブルーチンコールも再帰的に処理する)
#
#			マクロソースファイル中の !include 指定を読み取って、
#			指定されたファイルを読み込む
#			!define 指定で読み込む(読み込まない)パートを指定できる
#
#			マクロソースファイル中の "%" で囲まれた変数を environ.txt
#			から読み取った物で置き換える
#
#		実行方法＆引数：
#
#			gawk -f common.awk -f gen_mac.awk inputfile [outputfile]
#
#				inputfile	:	!include 文を含んだマクロファイル
#								(後述の SRCDIR からの相対パス or 絶対パス)
#				outputfile	:	出力マクロファイル名
#								(後述の MACDIR からの相対パス or 絶対パス)
#								省略時は inputfile の拡張子を .mac に
#								変えた物になる。
#

BEGIN	{
	#	デバッグフラグ
#	DEBUG = 1;

	#	AWK スクリプトファイル名
	SCRIPTNAME = "gen_mac.awk";

	#	エラーコード
	#		0	:	正常終了
	#		1	:	サブルーチン置き換えエラー(スクリプトは続行される)
	#		2	:	ファイルＩＯエラー(スクリプトは強制終了)
	#		255	:	引数/環境変数定義のエラー(　　　〃　　　)
	#
	ERROR = 0;

	#	引数の処理
	if( ARGC < 2 || ARGC > 3 ){
		printf("Usage: %s -f common.awk -f %s inputfile [outputfile]\n",ARGV[0],SCRIPTNAME);
		ERROR = 255;
		exit;
	}

	if( ARGC == 2 ){
		if( index(ARGV[1] "*",".mtp*") ) ext = ".mac";
		else if( index(ARGV[1] "*",".itp*") ) ext = ".ini";
		else ext = ".new";
		l = length(ARGV[1]);
		for(;l;l--) if( substr(ARGV[1],l,1)=="." ) break;
		ARGV[2] = substr(ARGV[1],1,(l?l-1:length(ARGV[1]))) ext;
	}

	#	入力マクロファイル名
	INFILE = declare_filename(ARGV[1],SRCDIR);

	#	出力マクロファイル名
	OUTFILE = declare_filename(ARGV[2],MACDIR);

	#	入力ファイルを INFILE にセット
	ARGV[1] = INFILE;
	delete ARGV[2];
	ARGC = 2;

	#	テンポラリファイルの初期化
	printf("") > TMPFILE;

	ERROR_MSG_HEADER = sprintf("In-file: [%s] Out-file: [%s]",INFILE,OUTFILE);
	if( DEBUG ){
		DB_ROUTINE_NUM = 0;
		DB_FOUND_LIBFILE_FAILED_NUM = 0;
		DB_FOUND_LIBDATA_FAILED_NUM = 0;
	}

	#	マクロライブラリ中のサブルーチンを取得
	#	AR_ROUTINENUM[libfilename]		:	libfilename 中のサブルーチンの数
	#	AR_ROUTINENAME[libfilename,id]	:	サブルーチン名を格納する
	get_corresp( LIBDIR ";" SRCDIR );

	NEEDROUTINE_NUM = 0;
	FS = "";
}

/^!include/	{
	if( split($0,buf," ") != 2 ) eprintf("Invalid include line.");
	else include_file( declare_filename(buf[2],SRCDIR) );
	next;
}

/^!define/	{
	n = split($0,buf," ");
	for(;n>1;n--) def_var[buf[n]] = "";
	next;
}

/%[A-Z0-9_]+%/	{
	if( DEBUG ) eprintf("Find Env. Replacement Request Line.\n");
	#	環境変数を反映させるためのフィルター
	n = split($0,buf,"%");
	$0 = "";
	in_flag = 0;
	for(i=1;i<n;i++){
		if( in_flag && buf[i] ~ /^[A-Z0-9_]+$/ ){
			if( DEBUG ) eprintf(sprintf("Find Env. Replacement Request : %s\n",buf[i]));
			env = get_env(buf[i]);
			if( DEBUG ){
				eprintf(sprintf("Env. Replacement : %s -> %s .\n",buf[i],env));
			}
			if( env != "" ) buf[i] = env;
			else buf[i] = "%" buf[i] "%";
			in_flag = 0;
		} else in_flag = 1;
		$0 = $0 buf[i];
	}
	$0 = $0 buf[n];
}

{
	print >> TMPFILE;
}

/^\/\/!HEADER$/	{
	printf("//\tGENERATED BY SUBROUTINE LIBRARY MANAGEMENT SCRIPT:\n")	>> TMPFILE;
	printf("//\t\tSOURCE FILENAME\t%s\n",substr(INFILE,length(SRCDIR)+2))	>> TMPFILE;
	printf("//\t\tOUTPUT FILENAME\t%s\n",substr(OUTFILE,length(MACDIR)+2))	>> TMPFILE;
	printf("//\t\tGENERATED DATE\t%s\n",strftime("%Y/%m/%d %H:%M:%S"))	>> TMPFILE;
}

/^[A-Za-z0-9_]+:$/	{
	routinename = substr($0,1,length($0)-1);
	if( DEBUG ) eprintf(sprintf("Subroutine [%s] is found.\n",routinename));
	if( !(routinename in AR_CUR_ROUTINE) ) AR_CUR_ROUTINE[routinename] = "";
}

/call[ \t]+[A-Za-z0-9_]+/	{
	find_call( $0 );
}

END	{
	for( i=0; i< NEEDROUTINE_NUM; i++ ){
		routine = AR_NEEDROUTINE[i];
		delete AR_NEEDROUTINE[i];
		if( !(routine in AR_CUR_ROUTINE) ){
			add_routine( routine );
			AR_CUR_ROUTINE[routine] = "";
		}
	}
	close(TMPFILE);
	if( ERROR < 255 ){
		if( DEBUG ){
			eprintf("Debug information:\n");
			eprintf(" GENERATED STRINGS:\n");
			eprintf(sprintf("  INPUT FILE : %s\n",INFILE));
			eprintf(sprintf("  OUTPUT FILE: %s\n",OUTFILE));
			eprintf(sprintf("  TEMP FILE  : %s\n",TMPFILE));
			for( routine in AR_CUR_ROUTINE )
				eprintf(sprintf("  FOUND ROUTINE: %s\n",routine));
			for( i=0; i<NEEDROUTINE_NUM; i++ ){
				if( AR_NEEDROUTINE[i] != "" )
					eprintf(sprintf("  UNADD ROUTINE: %s\n",AR_NEEDROUTINE[i]));
			}
			eprintf(" STATISTICS:\n");
			eprintf(sprintf("  INPUT LINE : %d\n",NR));
			eprintf(sprintf("  FOUND LINE : %d\n",DB_ROUTINE_NUM));
			eprintf(sprintf("  LIBFILE FOUND FAILED : %d\n",DB_FOUND_LIBFILE_FAILED_NUM));
			eprintf(sprintf("  LIBDATA FOUND FAILED : %d\n",DB_FOUND_LIBDATA_FAILED_NUM));
			eprintf(sprintf("  RETURN CODE: %d\n",ERROR));
		} else if ( !ERROR ) ERROR = movefile(TMPFILE,OUTFILE);
		if( (!DEBUG) && ERROR ){
			eprintf(sprintf("[%s] was not changed due to some errors.\n",OUTFILE));
			eprintf(sprintf("Output file is remaining as [%s].\n",TMPFILE));
		}
	}
	exit ERROR;
}

function	add_routine( routine	, libfile, routine_str )
#	指定サブルーチンを追加する関数
#
#	引数：
#		char*	routine	:	追加するサブルーチン名
#	戻り値：
#		int	:	成功なら = 0, ライブラリファイル検索失敗 = 1,
#				サブルーチン検索失敗 = 2
#
{
	if( DEBUG ) eprintf(sprintf("Adding subroutine [%s] ...\n",routine));
	if( (libfile = find_libfile(routine)) == "" ) return 1;
	if( (routine_str = get_routine(routine,libfile)) != "" ){
		printf("%s\n",routine_str) >> TMPFILE;
		if( DEBUG ) eprintf(sprintf("Adding [%s] is done.\n",routine));
		return 0;
	} else {
		eprintf(sprintf("Can't find [%s] in [%s].\n",routine,libfile));
		return 2;
	}
	return 0;
}

function	get_routine( routine, srcfile	,ret,line,routine_str,token,n,i )
#	ライブラリファイルからサブルーチン本体を得る関数
#
#	引数：
#		char*	routine	:	サブルーチン名
#		char*	srcfile	:	ライブラリファイル名
#	戻り値：
#		char*	:	サブルーチン本体
#
{
	routine_str = "";
	for(flg=0;;){
		ret = (getline line < srcfile );
		if( ret == -1 ){
			eprintf(sprintf("Fatal Error: Can't open file [%s].\n",srcfile));
			return "";
		} else if( !ret ) break;
		if( (!flg) && (line ~ ("^" routine ":")) ) flg = 1;
		if( flg ){
			if( line ~ /^#end_of_routine$/ ) break;
			routine_str = routine_str line "\n";
			find_call(line);
		}
	}
	close(srcfile);
	return routine_str;
}

function	find_libfile( routine	, ret, i, libname )
#	サブルーチン名からライブラリファイル名を得る関数
#
#	引数：
#		char*	routine	:	サブルーチン名
#	戻り値：
#		char*	:	ライブラリファイル(ベース)名
#
{
	for( libname in AR_ROUTINENUM ){
		for( i=1;i<=AR_ROUTINENUM[libname];i++ ){
			if( AR_ROUTINENAME[libname,i] == routine ){
				ret = AR_ROUTINEDIR[libname] "\\" libname;
				if( DEBUG )
					eprintf(sprintf("Subroutine [%s] is found in [%s].\n",routine,ret));
				return ret;
			}
		}
	}
	eprintf(sprintf("Error: Can't find the definition of [%s].\n",routine));
	ERROR = 1;
	return "";
}

function	find_call( line		, token, n, i )
#	サブルーチンコールを入力行から探す関数
#
#	引数：
#		char*	line	:	入力行
#	戻り値：
#		none
#
{
	n = split(line,token,"[ \t;:]+");
	for( i=1; i<n; i++ ){
		if( token[i] == "call" ){
			if( DEBUG ){
				DB_ROUTINE_NUM++;
				eprintf(sprintf("Subroutine call [%s] is found.\n",token[i+1]));
			}
			add_to_need(token[i+1]);
		} else if( token[i] == "//" ) break;
	}
	return;
}

function	add_to_need( routine	,i )
#	必要となるサブルーチンのテーブルにエントリを追加する関数
#
#	引数：
#		char*	routine	:	エントリに追加するサブルーチン名
#	戻り値：
#		none
#
{
	if( !(routine in AR_CUR_ROUTINE) ){
		for( i=0;i<NEEDROUTINE_NUM;i++ )
			if( AR_NEEDROUTINE[i] == routine ) return;
		if( DEBUG ) eprintf(sprintf("Subroutine [%s] is needed.\n",routine));
		AR_NEEDROUTINE[NEEDROUTINE_NUM++] = routine;
	}
	return;
}

function	include_file( file	,line,buf,read )
#	!include 指定に従ってファイルを読み込む関数
#
#	引数：
#		char*	line	:	!include 指定のある行
#	戻り値：
#		none
#
{
	read = 1;
	while( (getline line < file) > 0 ){
		if( line ~ /^!ifdef/ ){
			split(line,buf," ");
			read = (buf[2] in def_var);
		} else if( line ~ /^!ifndef/ ){
			split(line,buf," ");
			read = !(buf[2] in def_var);
		} else if( line ~ /^!endif/ ) read = 1;
		else if( read ){
			find_call( line );
			printf("%s\n",line) >> TMPFILE;
		}
	}
	close(file);
	return;
}
